<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>2048 - Premium Edition</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --container-bg: #1e293b;
            --cell-bg: #334155;
            --text-color: #f8fafc;
            --accent-color: #38bdf8;
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;

            --tile-2: #e2e8f0;
            --tile-4: #cbd5e1;
            --tile-8: #fcd34d;
            --tile-16: #fbbf24;
            --tile-32: #fb923c;
            --tile-64: #f87171;
            --tile-128: #f43f5e;
            --tile-256: #e11d48;
            --tile-512: #be123c;
            --tile-1024: #9f1239;
            --tile-2048: #881337;
            --tile-txt-dark: #0f172a;
            --tile-txt-light: #f8fafc;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            touch-action: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        header {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title-box h1 {
            margin: 0;
            font-size: 48px;
            font-weight: 800;
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;

        }

        .scores-container {
            display: flex;
            gap: 10px;
        }

        .score-box {
            background-color: var(--container-bg);
            padding: 5px 15px;
            border-radius: 8px;
            text-align: center;
            min-width: 80px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .score-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #94a3b8;
            font-weight: bold;
        }

        .score-value {
            font-size: 20px;
            font-weight: bold;
        }

        main {
            position: relative;
            padding: 10px;
        }

        #game-container {
            width: 340px;
            height: 340px;
            background-color: var(--container-bg);
            border-radius: 12px;
            padding: 10px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            gap: 10px;
            position: relative;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .grid-cell {
            background-color: var(--cell-bg);
            border-radius: 8px;
            width: 72.5px;
            height: 72.5px;
        }

        .tile-container {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 320px;
            height: 320px;
            pointer-events: none;
        }

        .tile {
            position: absolute;
            width: 72.5px;
            height: 72.5px;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 32px;
            font-weight: 800;
            transition: transform 100ms ease-in-out, background-color 100ms ease-in-out;
            z-index: 10;
        }

        .tile-new {
            animation: appear 200ms ease-out;
        }

        .tile-merged {
            animation: pop 200ms ease-in-out;
        }

        @keyframes appear {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }


        @keyframes pop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }

            100% {
                transform: scale(1);
            }
        }


        .tile-2 {
            background-color: var(--tile-2);
            color: var(--tile-txt-dark);
        }

        .tile-4 {
            background-color: var(--tile-4);
            color: var(--tile-txt-dark);
        }

        .tile-8 {
            background-color: var(--tile-8);
            color: var(--tile-txt-dark);
        }

        .tile-16 {
            background-color: var(--tile-16);
            color: var(--tile-txt-light);
        }

        .tile-32 {
            background-color: var(--tile-32);
            color: var(--tile-txt-light);
        }

        .tile-64 {
            background-color: var(--tile-64);
            color: var(--tile-txt-light);
        }

        .tile-128 {
            background-color: var(--tile-128);
            color: var(--tile-txt-light);
            font-size: 28px;
            box-shadow: 0 0 10px var(--tile-128);
        }

        .tile-256 {
            background-color: var(--tile-256);
            color: var(--tile-txt-light);
            font-size: 28px;
            box-shadow: 0 0 15px var(--tile-256);
        }

        .tile-512 {
            background-color: var(--tile-512);
            color: var(--tile-txt-light);
            font-size: 28px;
            box-shadow: 0 0 20px var(--tile-512);
        }

        .tile-1024 {
            background-color: var(--tile-1024);
            color: var(--tile-txt-light);
            font-size: 22px;
            box-shadow: 0 0 25px var(--tile-1024);
        }

        .tile-2048 {
            background-color: var(--tile-2048);
            color: var(--tile-txt-light);
            font-size: 22px;
            box-shadow: 0 0 30px var(--tile-2048);
        }

        .controls {
            width: 100%;
            max-width: 400px;
            padding: 20px;
            display: flex;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(135deg, #38bdf8, #2563eb);
            border: none;
            color: white;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(56, 189, 248, 0.4);
        }

        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 12px;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #game-over h2 {
            font-size: 40px;
            margin-bottom: 20px;
            color: var(--accent-color);
        }

        /* Safari Desktop support */
        @media (min-width: 500px) {
            #game-container {
                width: 450px;
                height: 450px;
            }

            .grid-cell,
            .tile {
                width: 100px;
                height: 100px;
            }

            .tile-container {
                width: 430px;
                height: 430px;
            }
        }
    </style>
</head>

<body>
    <header>
        <div class="title-box">
            <h1>2048</h1>
        </div>
        <div class="scores-container">
            <div class="score-box">
                <div class="score-label">Score</div>
                <div id="score" class="score-value">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Best</div>
                <div id="best-score" class="score-value">0</div>
            </div>
        </div>
    </header>

    <main>
        <div id="game-container">
            <!-- Grid -->
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>
            <div class="grid-cell"></div>

            <div id="tile-container" class="tile-container"></div>

            <div id="game-over">
                <h2>Game Over!</h2>
                <button class="btn" onclick="game.restart()">Try Again</button>
            </div>
        </div>
    </main>

    <div class="controls">
        <button class="btn" onclick="game.restart()">New Game</button>
    </div>

    <script>
        class Game2048 {
            constructor() {
                this.container = document.getElementById('tile-container');
                this.scoreDisplay = document.getElementById('score');
                this.bestDisplay = document.getElementById('best-score');
                this.gameOverDisplay = document.getElementById('game-over');

                this.size = 4;
                this.grid = [];
                this.score = 0;
                this.bestScore = parseInt(localStorage.getItem('2048-best')) || 0;
                this.bestDisplay.textContent = this.bestScore;

                this.setupInputs();
                this.restart();
            }

            restart() {
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(null));
                this.score = 0;
                this.updateScore(0);
                this.container.innerHTML = '';
                this.gameOverDisplay.style.display = 'none';
                this.addRandomTile();
                this.addRandomTile();
                this.render();
            }

            addRandomTile() {
                const emptyCells = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (!this.grid[r][c]) emptyCells.push({ r, c });
                    }
                }
                if (emptyCells.length > 0) {
                    const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                    this.grid[r][c] = {
                        value: Math.random() < 0.9 ? 2 : 4,
                        id: Date.now() + Math.random()
                    };
                }
            }

            updateScore(amount) {
                this.score += amount;
                this.scoreDisplay.textContent = this.score;
                if (this.score > this.bestScore) {
                    this.bestScore = this.score;
                    this.bestDisplay.textContent = this.bestScore;
                    localStorage.setItem('2048-best', this.bestScore);
                }
            }

            render() {
                const cellSize = document.querySelector('.grid-cell').offsetWidth;
                const gap = 10;

                // Track current tile elements
                const currentTiles = new Map();
                document.querySelectorAll('.tile').forEach(el => {
                    currentTiles.set(el.dataset.id, el);
                });

                const updatedIds = new Set();

                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        const tile = this.grid[r][c];
                        if (tile) {
                            let tileEl = currentTiles.get(String(tile.id));
                            const className = `tile tile-${tile.value}`;

                            if (!tileEl) {
                                tileEl = document.createElement('div');
                                tileEl.className = className + ' tile-new';
                                tileEl.textContent = tile.value;
                                tileEl.dataset.id = tile.id;
                                this.container.appendChild(tileEl);
                            } else {
                                // Only update if changed to avoid re-triggering transitions/animations
                                if (tileEl.textContent !== String(tile.value)) {
                                    tileEl.textContent = tile.value;
                                }
                                if (!tileEl.classList.contains(`tile-${tile.value}`)) {
                                    tileEl.className = className;
                                }
                            }

                            if (tile.mergedFrom) {
                                tileEl.classList.add('tile-merged');
                                delete tile.mergedFrom; // Only animate once
                            }

                            const x = c * (cellSize + gap);
                            const y = r * (cellSize + gap);
                            tileEl.style.transform = `translate(${x}px, ${y}px)`;
                            updatedIds.add(String(tile.id));
                        }
                    }
                }

                // Remove tiles that are no longer in the grid
                currentTiles.forEach((el, id) => {
                    if (!updatedIds.has(id)) {
                        el.remove();
                    }
                });

                // Clear temporary animation classes after they finish
                setTimeout(() => {
                    document.querySelectorAll('.tile-new, .tile-merged').forEach(el => {
                        el.classList.remove('tile-new', 'tile-merged');
                    });
                }, 250);
            }


            move(direction) {
                // 0: up, 1: right, 2: down, 3: left
                let moved = false;
                const newGrid = Array(this.size).fill().map(() => Array(this.size).fill(null));

                const rotate = (grid) => {
                    const result = Array(this.size).fill().map(() => Array(this.size).fill(null));
                    for (let r = 0; r < this.size; r++) {
                        for (let c = 0; c < this.size; c++) {
                            result[c][this.size - 1 - r] = grid[r][c];
                        }
                    }
                    return result;
                };

                let tempGrid = this.grid;
                for (let i = 0; i < direction; i++) tempGrid = rotate(tempGrid);

                for (let r = 0; r < this.size; r++) {
                    let row = tempGrid[r].filter(cell => cell !== null);
                    for (let i = 0; i < row.length - 1; i++) {
                        if (row[i].value === row[i + 1].value) {
                            const newValue = row[i].value * 2;
                            row[i] = {
                                value: newValue,
                                id: row[i].id,
                                mergedFrom: [row[i].id, row[i + 1].id]
                            };
                            this.updateScore(newValue);
                            row.splice(i + 1, 1);
                            moved = true;
                        }
                    }
                    while (row.length < this.size) row.push(null);

                    for (let c = 0; c < this.size; c++) {
                        if (tempGrid[r][c] !== row[c]) moved = true;
                        tempGrid[r][c] = row[c];
                    }
                }

                for (let i = 0; i < (4 - direction) % 4; i++) tempGrid = rotate(tempGrid);
                this.grid = tempGrid;

                if (moved) {
                    this.addRandomTile();
                    this.render();
                    if (this.isGameOver()) {
                        this.gameOverDisplay.style.display = 'flex';
                    }
                }
            }

            isGameOver() {
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        if (!this.grid[r][c]) return false;
                        if (c < this.size - 1 && this.grid[r][c].value === this.grid[r][c + 1].value) return false;
                        if (r < this.size - 1 && this.grid[r][c].value === this.grid[r + 1][c].value) return false;
                    }
                }
                return true;
            }

            setupInputs() {
                let touchStartX, touchStartY;

                window.addEventListener('touchstart', e => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, { passive: false });

                window.addEventListener('touchend', e => {
                    if (!touchStartX || !touchStartY) return;

                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;
                    const absDx = Math.abs(dx);
                    const absDy = Math.abs(dy);

                    if (Math.max(absDx, absDy) > 30) {
                        if (absDx > absDy) {
                            // horizontal
                            this.move(dx > 0 ? 2 : 0); // RIGHT: 2, LEFT: 0
                        } else {
                            // vertical
                            this.move(dy > 0 ? 1 : 3); // DOWN: 1, UP: 3
                        }
                    }
                    touchStartX = touchStartY = null;
                }, { passive: false });

                window.addEventListener('keydown', e => {
                    switch (e.key) {
                        case 'ArrowUp': this.move(3); break;
                        case 'ArrowRight': this.move(2); break;
                        case 'ArrowDown': this.move(1); break;
                        case 'ArrowLeft': this.move(0); break;
                    }
                });
            }
        }

        const game = new Game2048();
    </script>
</body>

</html>